from collections.abc import Iterable, MutableSequence
from typing import overload

def project[T](original: MutableSequence[T], fallback: bool = False) -> MutableSequence[T]: ...

class _MutableSequence[T](MutableSequence[T]):
    """
    As MutableSequence is an abstract base class, the type stubs need to explicitly annotate the overriden
    methods which can then be referenced for each optimized sequence type.
    """

    @overload
    def __getitem__(self, index: int) -> T: ...
    @overload
    def __getitem__(self, index: slice) -> MutableSequence[T]: ...
    @overload
    def __setitem__(self, index: int, value: T) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: Iterable[T]) -> None: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, index: slice) -> None: ...
    def __len__(self) -> int: ...
    def insert(self, index: int, value: T) -> None: ...

class Size0MutableSequence[T](_MutableSequence[T]):
    def __init__(self) -> None: ...

class Size1MutableSequence[T](_MutableSequence[T]):
    def __init__(self, item1: T) -> None: ...

class Size2MutableSequence[T](_MutableSequence[T]):
    def __init__(self, item1: T, item2: T) -> None: ...

class Size3MutableSequence[T](_MutableSequence[T]):
    def __init__(self, item1: T, item2: T, item3: T) -> None: ...

class Size0FallbackMutableSequence[T](_MutableSequence[T]):
    def __init__(self) -> None: ...

class Size1FallbackMutableSequence[T](_MutableSequence[T]):
    def __init__(self, item1: T) -> None: ...

class Size2FallbackMutableSequence[T](_MutableSequence[T]):
    def __init__(self, item1: T, item2: T) -> None: ...

class Size3FallbackMutableSequence[T](_MutableSequence[T]):
    def __init__(self, item1: T, item2: T, item3: T) -> None: ...
